Complete Folder Structure with All Services

ecommerce-microservices/
├── shared/
│   ├── __init__.py
│   └── schemas.py
├── user_service/
│   ├── models/
│   ├── routers/
│   ├── dependencies.py
│   ├── database.py
│   ├── main.py
│   ├── Dockerfile
│   └── requirements.txt
├── product_service/
│   ├── models/
│   ├── routers/ 
│   ├── dependencies.py
│   ├── database.py
│   ├── main.py
│   ├── Dockerfile
│   └── requirements.txt
├── order_service/
│   ├── models/
│   ├── routers/
│   ├── dependencies.py
│   ├── database.py
│   ├── main.py
│   ├── Dockerfile
│   └── requirements.txt
├── api_gateway/
│   ├── dependencies.py
│   ├── main.py
│   ├── Dockerfile
│   └── requirements.txt
├── docker-compose.yml
├── .env
└── requirements.txt


message_queue.py

which service is using this message queue?


The message_queue.py file would be used by multiple services in our e-commerce microservices architecture. Let me show you which services use it and how:

Services Using Message Queue
1. Order Service (Primary User)
   - Notifies other services when orders are created/updated
   - Publishes order events for other services to consume

2. Product Service
   - Listens for order events to update inventory
   - Publishes product update events

3. User Service
   - Listens for order events to update user statistics
   - Publishes user registration events

4. API Gateway (Optional)
   - Could publish analytics events
   - Monitor service communication

Implementation Example:
shared/message_queue.py

Service-Specific Usage:
1. Order Service Using Message Queue

    order_service/event_handlers.py
    order_service/main.py (updated)
    order_service/routers/orders.py (updated)

2. Product Service Using Message Queue

    product_service/event_handlers.py
    product_service/main.py (updated)
    product_service/routers/products.py (updated)

3. User Service Using Message Queue

    user_service/event_handlers.py
    user_service/main.py (updated)
    user_service/routers/users.py (updated)









Real-World Usage Examples
Example 1: Customer Places Order (Frontend)

// Frontend uses REST API (synchronous)
const response = await fetch('/api/orders/', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
        items: [
            { product_id: 'prod-123', quantity: 2, price: 29.99 }
        ],
        total_amount: 59.98
    })
});

const order = await response.json();
console.log('Order created:', order);
// Immediate response from REST API




Example 2: What Happens Behind the Scenes

# 1. REST API called (synchronous)
# 2. Order created in database  
# 3. Immediate response to client
# 4. Message queue events published (asynchronous):
#    - Product Service: Update inventory
#    - User Service: Update order statistics
#    - Email Service: Send confirmation email
#    - Analytics Service: Track sales data


Example 3: Admin Updates Product Stock

# REST API call (synchronous update)
PATCH /api/products/prod-123/stock
{
    "stock": 50
}

# Behind the scenes:
# 1. Stock updated in database (immediate)
# 2. Response returned to admin
# 3. Message queue: Notify other services about stock change
#    - Search Service: Reindex product
#    - Cache Service: Invalidate cache
#    - Notification Service: Alert if stock was low


Benefits of This Hybrid Approach
✅ REST APIs Provide:
Immediate feedback to users

Synchronous operations that need instant results

Simple client integration (HTTP/JSON)

Real-time data retrieval

✅ Message Queue Provides:
Background processing without blocking users

Service decoupling (services don't need to be available)

Event-driven architecture for complex workflows

Scalability (process events when resources are available)

Testing Both Patterns:

Test REST APIs (Synchronous)

# Create order via REST API
curl -X POST http://localhost:8000/orders/ \
  -H "Content-Type: application/json" \
  -d '{
    "items": [{"product_id": "prod-1", "quantity": 2, "price": 29.99}],
    "total_amount": 59.98
  }'

# Immediate response:
{
  "id": "order-123",
  "status": "pending",
  "total_amount": 59.98
}


Monitor Message Queue Events (Asynchronous)

# Check RabbitMQ management UI
# http://localhost:15672 (guest/guest)

# See events flowing through queues:
# - order.created
# - inventory.updated  
# - user.order_placed
# - email.confirmation_sent


Summary

Both REST APIs and Message Queue work together:

REST APIs = For direct client-service communication needing immediate responses

Message Queue = For service-service communication that can happen asynchronously

This hybrid approach gives you the best of both worlds: responsive user interfaces + scalable backend processing!